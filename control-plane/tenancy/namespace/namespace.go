package namespace

import (
	"context"
	"fmt"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/anypb"

	"github.com/hashicorp/consul/proto-public/pbresource"
	pbtenancy "github.com/hashicorp/consul/proto-public/pbtenancy/v2beta1"
)

// DeletionTimestampKey is the key in a resource's metadata that stores the timestamp
// when a resource was marked for deletion. This only applies to resources with finalizers.
const DeletionTimestampKey = "deletionTimestamp"

// EnsureDeleted ensures a Consul namespace with name ns is deleted. If it is already not found
// the call to delete will be skipped.
func EnsureDeleted(ctx context.Context, client pbresource.ResourceServiceClient, ap, ns string) error {
	// TODO: fix common imports
	//if ns == common.WildcardNamespace || ns == common.DefaultNamespaceName {
	if ns == "*" || ns == "default" {
		return nil
	}

	// Check if the Consul namespace exists.
	rsp, err := client.Read(ctx, &pbresource.ReadRequest{Id: &pbresource.ID{
		Name:    ns,
		Type:    pbtenancy.NamespaceType,
		Tenancy: &pbresource.Tenancy{Partition: ap},
	}})

	switch {
	case status.Code(err) == codes.NotFound:
		// Nothing to do
		return nil
	case err != nil:
		// Unexpected error
		return fmt.Errorf("namespace read failed: %w", err)

	case isMarkedForDeletion(rsp.Resource):
		// Deletion already in progress
		return nil
	default:
		// Namespace found, so non-CAS delete it.

		_, err = client.Delete(ctx, &pbresource.DeleteRequest{Id: rsp.Resource.Id, Version: ""})
		if err != nil {
			return fmt.Errorf("namespace delete failed: %w", err)
		}
		return nil
	}
}

// EnsureExists ensures a Consul namespace with name ns exists. If it doesn't,
// it will create it.
//
// Boolean return value indicates if the namespace was created by this call.
func EnsureExists(ctx context.Context, client pbresource.ResourceServiceClient, ap, ns string) (bool, error) {
	// TOOD: make constants
	if ns == "*" || ns == "default" {
		return false, nil
	}

	// Check if the Consul namespace exists.
	rsp, err := client.Read(ctx, &pbresource.ReadRequest{Id: &pbresource.ID{
		Name:    ns,
		Type:    pbtenancy.NamespaceType,
		Tenancy: &pbresource.Tenancy{Partition: ap},
	}})

	switch {
	case err == nil && !isMarkedForDeletion(rsp.Resource):
		// Found, but delete in progress
		return false, fmt.Errorf("consul namespace %q deletion in progress", ns)
	case err == nil:
		// Found, nothing to do
		return false, nil
	case status.Code(err) != codes.NotFound:
		// Unexpected error
		return false, fmt.Errorf("consul namespace read failed: %w", err)
	}

	// Consul namespace not found, so create it
	// TODO: Handle creation of crossNSACLPolicy when V2 ACLs are supported

	nsData, err := anypb.New(&pbtenancy.Namespace{Description: "Auto-generated by consul-k8s"})
	if err != nil {
		return false, err
	}

	_, err = client.Write(ctx, &pbresource.WriteRequest{Resource: &pbresource.Resource{
		Id: &pbresource.ID{
			Name:    ns,
			Type:    pbtenancy.NamespaceType,
			Tenancy: &pbresource.Tenancy{Partition: ap},
		},
		Metadata: map[string]string{"external-source": "kubernetes"},
		Data:     nsData,
	}})

	if err != nil {
		return false, fmt.Errorf("consul namespace create failed: %w", err)
	}
	return true, nil
}

// isMarkedForDeletion returns true if a resource has been marked for deletion,
// false otherwise.
func isMarkedForDeletion(res *pbresource.Resource) bool {
	if res.Metadata == nil {
		return false
	}
	_, ok := res.Metadata[DeletionTimestampKey]
	return ok
}
